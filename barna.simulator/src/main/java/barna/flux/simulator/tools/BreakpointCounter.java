/*
 * This file is part of the Flux Library.
 *
 * The code of the Flux Library may be freely distributed and modified under the terms of the
 * European Union Public Licence (EUPL) published on the web site <http://www.osor.eu/eupl/european-union-public-licence-eupl-v.1.1>.
 * Copyright for the code is held jointly by the individual authors, who should be listed
 * in @author doc comments. According to Article 5 and Article 11 of the EUPL, publications that
 * include results produced by the Flux Library are liable to reference the Work,
 * see the Flux Library homepage <http://flux.sammeth.net> for more information.
 */

package barna.flux.simulator.tools;

import barna.commons.cli.jsap.JSAPParameters;
import barna.commons.launcher.FluxTool;
import barna.commons.log.Log;
import com.martiansoftware.jsap.JSAPResult;
import com.martiansoftware.jsap.Parameter;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

/**
 * Count and print breakpoint distribution
 *
 * @author Thasso Griebel (Thasso.Griebel@googlemail.com)
 */

public class BreakpointCounter implements FluxTool {

    private File bedFile;
    private int bins = 20;
    private boolean bounds;
    private int minLength = 0;
    private int maxLength = Integer.MAX_VALUE;



    public File getBedFile() {
        return bedFile;
    }

    public void setBedFile(final File bedFile) {
        this.bedFile = bedFile;
    }

    public boolean isBounds() {
        return bounds;
    }


    public void setBounds(final boolean bounds) {
        this.bounds = bounds;
    }

    public int getMinLength() {
        return minLength;
    }


    public void setMinLength(final int minLength) {
        this.minLength = minLength;
    }

    public int getMaxLength() {
        return maxLength;
    }


    public void setMaxLength(final int maxLength) {
        this.maxLength = maxLength;
    }

    @Override
    public String getName() {
        return "breakpoint";
    }

    @Override
    public String getDescription() {
        return "Plot the breakpoint distribution of a .bed file";
    }

    @Override
    public List<Parameter> getParameter() {
        ArrayList<Parameter> parameters = new ArrayList<Parameter>();

        parameters.add(JSAPParameters.flaggedParameter("input", 'i').type(File.class).help(".bed input file").valueName("bed").required().get());
        parameters.add(JSAPParameters.switchParameter("bounds", 'b').type(File.class).help("Respect transcript bounds and ignore reads outside (negative breakpoints or breakpoints after transcript end)").get());
        parameters.add(JSAPParameters.flaggedParameter("min").help("Minimum transcript length").type(Integer.class).defaultValue("0").get());
        parameters.add(JSAPParameters.flaggedParameter("max").help("Maximum transcript length").type(Integer.class).defaultValue("100000000").get());
        return parameters;

    }

    @Override
    public boolean validateParameter(JSAPResult args) {
        setBedFile(args.getFile("input"));
        setMaxLength(args.getInt("max"));
        setMinLength(args.getInt("min"));
        setBounds(args.userSpecified("bounds"));
        if (bedFile == null || !bedFile.exists()) {
            Log.error("Please specify a .bed file");
            return false;
        }
        return true;
    }

    @Override
    public Object call() throws Exception {
        BufferedReader reader = null;
        long[] sense = new long[bins];
        long[] antiSense = new long[bins];

        double b = 100.0 / bins;
        try {
            reader = new BufferedReader(new FileReader(getBedFile()));

            String line = null;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }

                String[] e = line.split("\\s+");
                if (e.length < 4) {
                    throw new RuntimeException("Unable to find FRMD name for a read. Are you sure you passed a .bed file generated by the Flux Simulator ?");
                }
                String frmd = e[3];
                String[] elements = frmd.split("\\:");
                try {
                    int length = Integer.parseInt(elements[4]);
                    int breakPoint = Integer.parseInt(elements[7]);
                    char direction = Character.toUpperCase(elements[8].charAt(0));

                    if (length < minLength || length > maxLength) {
                        continue;
                    }
                    // negative starts
                    if (!bounds) {
                        if (breakPoint < 0) {
                            breakPoint = 0;
                        }
                        if (breakPoint > length) {
                            breakPoint = length;
                        }
                    } else {
                        if (breakPoint < 0 || breakPoint > length) {
                            continue;
                        }
                    }

                    // percent
                    double p = (breakPoint / (double) length) * 100.0;

                    double binD = Math.ceil(p / b) - 1.0;
                    if (binD < 0) {
                        binD = 0;
                    }
                    int bin = (int) binD;
                    if (direction == 'A') {
                        antiSense[bin]++;
                    } else if (direction == 'S') {
                        sense[bin]++;
                    } else {
                        throw new RuntimeException("Unknown direction " + direction);
                    }
                } catch (Exception error) {
                    throw new RuntimeException("Unable to parse FRMD name for a read.\n" +
                            " Are you sure you passed a .bed file generated by the Flux Simulator ?\n\n" +
                            "The line was: " + line + "\n" +
                            "With FRMD: " + frmd, error);
                }
            }

        } finally {
            if (reader != null) {
                reader.close();
            }
        }

        // print

        int x = (int) Math.floor(b);
        Log.println("Bin\tSense\tAntisense");
        for (int i = 0; i < bins; i++) {
            Log.println(((i + 1) * x) + "\t" + sense[i] + "\t" + antiSense[i]);
        }

        return null;
    }
}
