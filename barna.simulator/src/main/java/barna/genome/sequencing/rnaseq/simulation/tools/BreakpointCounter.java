/*
 * This file is part of the Flux Library.
 *
 * The code of the Flux Library may be freely distributed and modified under the terms of the
 * European Union Public Licence (EUPL) published on the web site <http://www.osor.eu/eupl/european-union-public-licence-eupl-v.1.1>.
 * Copyright for the code is held jointly by the individual authors, who should be listed
 * in @author doc comments. According to Article 5 and Article 11 of the EUPL, publications that
 * include results produced by the Flux Library are liable to reference the Work,
 * see the Flux Library homepage <http://flux.sammeth.net> for more information.
 */

package barna.genome.sequencing.rnaseq.simulation.tools;

import barna.commons.launcher.FluxTool;
import barna.commons.launcher.HelpPrinter;
import barna.commons.log.Log;
import org.cyclopsgroup.jcli.ArgumentProcessor;
import org.cyclopsgroup.jcli.annotation.Cli;
import org.cyclopsgroup.jcli.annotation.Option;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

/**
 * Count and print breakpoint distribution
 *
 * @author Thasso Griebel (Thasso.Griebel@googlemail.com)
 */
@Cli(name = "breakpoint", description = "Plot the breakpoint distribution of a .bed file")
public class BreakpointCounter implements FluxTool {

    private File bedFile;
    private int bins = 20;
    private boolean bounds;
    private int minLength = 0;
    private int maxLength = Integer.MAX_VALUE;


    @Option(name = "i", longName = "input", description = ".bed input file")
    public File getBedFile() {
        return bedFile;
    }

    public void setBedFile(final File bedFile) {
        this.bedFile = bedFile;
    }

    public boolean isBounds() {
        return bounds;
    }

    @Option(name = "b", longName = "bounds", description = "Respect transcript bounds and ignore reads outside (negative breakpoints or breakpoints after transcript end)")
    public void setBounds(final boolean bounds) {
        this.bounds = bounds;
    }

    public int getMinLength() {
        return minLength;
    }

    @Option(name = "m", longName = "min", description = "Minimum transcript length", defaultValue = "0")
    public void setMinLength(final int minLength) {
        this.minLength = minLength;
    }

    public int getMaxLength() {
        return maxLength;
    }

    @Option(name = "x", longName = "max", description = "Maximum transcript length", defaultValue = "100000000")
    public void setMaxLength(final int maxLength) {
        this.maxLength = maxLength;
    }

    @Override
    public boolean validateParameters(final HelpPrinter printer, final ArgumentProcessor toolArguments) {
        if (bedFile == null || !bedFile.exists()) {
            printer.out.println("Please specify a .bed file");
            return false;
        }
        return true;
    }

    @Override
    public Object call() throws Exception {
        BufferedReader reader = null;
        long[] sense = new long[bins];
        long[] antiSense = new long[bins];

        double b = 100.0 / bins;
        try {
            reader = new BufferedReader(new FileReader(getBedFile()));

            String line = null;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }

                String[] e = line.split("\\s+");
                if (e.length < 4) {
                    throw new RuntimeException("Unable to find FRMD name for a read. Are you sure you passed a .bed file generated by the Flux Simulator ?");
                }
                String frmd = e[3];
                String[] elements = frmd.split("\\:");
                try {
                    int length = Integer.parseInt(elements[4]);
                    int breakPoint = Integer.parseInt(elements[7]);
                    char direction = Character.toUpperCase(elements[8].charAt(0));

                    if (length < minLength || length > maxLength) {
                        continue;
                    }
                    // negative starts
                    if (!bounds) {
                        if (breakPoint < 0) {
                            breakPoint = 0;
                        }
                        if (breakPoint > length) {
                            breakPoint = length;
                        }
                    } else {
                        if (breakPoint < 0 || breakPoint > length) {
                            continue;
                        }
                    }

                    // percent
                    double p = (breakPoint / (double) length) * 100.0;

                    double binD = Math.ceil(p / b) - 1.0;
                    if (binD < 0) {
                        binD = 0;
                    }
                    int bin = (int) binD;
                    if (direction == 'A') {
                        antiSense[bin]++;
                    } else if (direction == 'S') {
                        sense[bin]++;
                    } else {
                        throw new RuntimeException("Unknown direction " + direction);
                    }
                } catch (Exception error) {
                    throw new RuntimeException("Unable to parse FRMD name for a read.\n" +
                            " Are you sure you passed a .bed file generated by the Flux Simulator ?\n\n" +
                            "The line was: " + line + "\n" +
                            "With FRMD: " + frmd, error);
                }
            }

        } finally {
            if (reader != null) {
                reader.close();
            }
        }

        // print

        int x = (int) Math.floor(b);
        Log.println("Bin\tSense\tAntisense");
        for (int i = 0; i < bins; i++) {
            Log.println(((i + 1) * x) + "\t" + sense[i] + "\t" + antiSense[i]);
        }

        return null;
    }
}
